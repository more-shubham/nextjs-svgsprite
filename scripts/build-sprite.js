#!/usr/bin/env node

/**
 * Build SVG Sprite Script
 * 
 * This script:
 * - Reads all .svg files from the svg-icons directory
 * - Combines them into a single SVG sprite
 * - Outputs the sprite to public/icons-sprite.svg
 */

const fs = require('fs');
const path = require('path');
const svgstore = require('svgstore');

// Configuration
const SVG_DIR = path.join(process.cwd(), 'svg-icons');
const OUTPUT_PATH = path.join(process.cwd(), 'public', 'icons-sprite.svg');
const TYPES_OUTPUT_PATH = path.join(process.cwd(), 'components', 'icon-types.ts');

/**
 * Ensure a directory exists, create if it doesn't
 */
function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Get all SVG files from a directory
 */
function getSvgFiles(dir) {
  if (!fs.existsSync(dir)) {
    console.warn(`Warning: SVG directory not found at ${dir}`);
    return [];
  }

  return fs.readdirSync(dir)
    .filter(file => file.endsWith('.svg'))
    .map(file => ({
      name: path.basename(file, '.svg'),
      path: path.join(dir, file),
    }));
}

/**
 * Generate TypeScript type definitions for icon names
 */
function generateTypeDefinitions(iconNames) {
  const typeDefinition = `/**
 * Auto-generated TypeScript types for SVG sprite icons
 * Generated from svg-icons directory
 * 
 * DO NOT EDIT THIS FILE MANUALLY - it is auto-generated
 */

export type IconName = ${iconNames.length > 0 ? iconNames.map(name => `'${name}'`).join(' | ') : 'never'};

export const iconNames = [${iconNames.map(name => `'${name}'`).join(', ')}] as const;
`;

  ensureDirectoryExists(path.dirname(TYPES_OUTPUT_PATH));
  fs.writeFileSync(TYPES_OUTPUT_PATH, typeDefinition);
  console.log(`\nTypeScript types generated at: ${TYPES_OUTPUT_PATH}`);
  
  if (iconNames.length === 0) {
    console.warn('⚠️  No icons found. IconName type is set to "never" to enforce type safety.');
    console.warn('   Add SVG files to svg-icons/ and re-run build:sprite to generate icon types.');
  }
}

/**
 * Build the SVG sprite
 */
function buildSprite() {
  console.log('Building SVG sprite...');

  // Initialize svgstore
  const sprites = svgstore({
    svgAttrs: {
      xmlns: 'http://www.w3.org/2000/svg',
      'xmlns:xlink': 'http://www.w3.org/1999/xlink',
      style: 'display: none;',
    },
    copyAttrs: ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    cleanDefs: true,
    cleanSymbols: true,
  });

  // Get all SVG files
  const svgFiles = getSvgFiles(SVG_DIR);

  if (svgFiles.length === 0) {
    console.warn('No SVG files found. Creating empty sprite.');
    ensureDirectoryExists(path.dirname(OUTPUT_PATH));
    fs.writeFileSync(OUTPUT_PATH, '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"></svg>');
    generateTypeDefinitions([]);
    return;
  }

  console.log(`Found ${svgFiles.length} SVG file(s):`);

  const iconNames = [];

  // Add each SVG to the sprite
  svgFiles.forEach(({ name, path: filePath }) => {
    try {
      const svgContent = fs.readFileSync(filePath, 'utf8');
      sprites.add(name, svgContent);
      iconNames.push(name);
      console.log(`  ✓ ${name}`);
    } catch (error) {
      console.error(`  ✗ Error adding ${name}:`, error.message);
    }
  });

  // Ensure output directory exists
  ensureDirectoryExists(path.dirname(OUTPUT_PATH));

  // Write the sprite file
  const spriteContent = sprites.toString();
  fs.writeFileSync(OUTPUT_PATH, spriteContent);

  // Generate TypeScript type definitions
  generateTypeDefinitions(iconNames);

  console.log(`\nSprite generated successfully at: ${OUTPUT_PATH}`);
  console.log(`Total icons: ${svgFiles.length}`);
}

// Run the build
try {
  buildSprite();
} catch (error) {
  console.error('Error building sprite:', error);
  process.exit(1);
}
