#!/usr/bin/env node

/**
 * Build SVG Sprite Script
 * 
 * This script:
 * - Reads all .svg files from the svg-icons directory
 * - Combines them into a single SVG sprite
 * - Outputs the sprite to public/icons-sprite.svg
 */

const fs = require('fs');
const path = require('path');
const svgstore = require('svgstore');

// Configuration
const SVG_DIR = path.join(process.cwd(), 'svg-icons');
const OUTPUT_PATH = path.join(process.cwd(), 'public', 'icons-sprite.svg');
const TYPES_OUTPUT_PATH = path.join(process.cwd(), 'components', 'icon-types.ts');

/**
 * Normalize icon name to kebab-case
 * Converts: sunMoon, SunMoon, sun_moon, "sun moon", "sun  moon" → sun-moon
 * 
 * @param {string} name - The original icon name
 * @returns {string} - The normalized kebab-case name
 */
function normalizeIconName(name) {
  return name
    // Replace multiple spaces with single space first
    .replace(/\s+/g, ' ')
    // Replace spaces with hyphens
    .replace(/\s/g, '-')
    // Handle PascalCase and camelCase: insert hyphen before uppercase letters
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    // Replace underscores with hyphens
    .replace(/_/g, '-')
    // Convert to lowercase
    .toLowerCase()
    // Remove any duplicate hyphens
    .replace(/-+/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-|-$/g, '');
}

/**
 * Ensure a directory exists, create if it doesn't
 */
function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Get all SVG files from a directory recursively
 * Supports namespaces via subdirectories (e.g., sidebar/home.svg → sidebar:home)
 * Nested namespaces: sidebar/nav/icon.svg → sidebar:nav:icon
 * All folder and file names are normalized to kebab-case
 */
function getSvgFiles(dir, namespace = '', originalNamespace = '') {
  if (!fs.existsSync(dir)) {
    console.warn(`Warning: SVG directory not found at ${dir}`);
    return [];
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];

  entries.forEach(entry => {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      // Normalize folder name to kebab-case
      const normalizedFolderName = normalizeIconName(entry.name);
      // Build namespace path with kebab-case folder names
      const newNamespace = namespace ? `${namespace}:${normalizedFolderName}` : normalizedFolderName;
      const newOriginalNamespace = originalNamespace ? `${originalNamespace}/${entry.name}` : entry.name;
      
      // Recursively process subdirectories as namespaces
      files = files.concat(getSvgFiles(fullPath, newNamespace, newOriginalNamespace));
    } else if (entry.isFile() && entry.name.endsWith('.svg')) {
      const originalFileName = path.basename(entry.name, '.svg');
      const normalizedFileName = normalizeIconName(originalFileName);
      const fullIconName = namespace ? `${namespace}:${normalizedFileName}` : normalizedFileName;
      const fullOriginalName = originalNamespace ? `${originalNamespace}/${originalFileName}` : originalFileName;
      
      files.push({
        originalName: fullOriginalName,
        name: fullIconName,
        path: fullPath,
      });
    }
  });

  return files;
}

/**
 * Remove duplicate icons and show warnings
 */
function deduplicateIcons(files) {
  const uniqueIcons = new Map();
  const duplicates = [];

  files.forEach(file => {
    if (uniqueIcons.has(file.name)) {
      // Found a duplicate
      const existing = uniqueIcons.get(file.name);
      if (!duplicates.some(d => d.name === file.name)) {
        duplicates.push({
          name: file.name,
          files: [existing.originalName, file.originalName]
        });
      } else {
        // Add to existing duplicate entry
        const dup = duplicates.find(d => d.name === file.name);
        dup.files.push(file.originalName);
      }
    } else {
      uniqueIcons.set(file.name, file);
    }
  });

  // Show warnings for duplicates
  if (duplicates.length > 0) {
    console.warn('\n⚠️  Warning: Duplicate icon names detected after normalization:');
    duplicates.forEach(({ name, files }) => {
      console.warn(`   "${name}" found in: [${files.join(', ')}]`);
    });
    console.warn('   These duplicates have been removed. Only the first occurrence is kept.\n');
  }

  return Array.from(uniqueIcons.values());
}

/**
 * Generate TypeScript type definitions for icon names
 */
function generateTypeDefinitions(iconNames) {
  const typeDefinition = `/**
 * Auto-generated TypeScript types for SVG sprite icons
 * Generated from svg-icons directory
 * 
 * DO NOT EDIT THIS FILE MANUALLY - it is auto-generated
 */

export type IconName = ${iconNames.length > 0 ? iconNames.map(name => `'${name}'`).join(' | ') : 'never'};

export const iconNames = [${iconNames.map(name => `'${name}'`).join(', ')}] as const;
`;

  ensureDirectoryExists(path.dirname(TYPES_OUTPUT_PATH));
  fs.writeFileSync(TYPES_OUTPUT_PATH, typeDefinition);
  console.log(`\nTypeScript types generated at: ${TYPES_OUTPUT_PATH}`);
  
  if (iconNames.length === 0) {
    console.warn('⚠️  No icons found. IconName type is set to "never" to enforce type safety.');
    console.warn('   Add SVG files to svg-icons/ and re-run build:sprite to generate icon types.');
  }
}

/**
 * Build the SVG sprite
 */
function buildSprite() {
  console.log('Building SVG sprite...');

  // Initialize svgstore
  const sprites = svgstore({
    svgAttrs: {
      xmlns: 'http://www.w3.org/2000/svg',
      'xmlns:xlink': 'http://www.w3.org/1999/xlink',
      style: 'display: none;',
    },
    copyAttrs: ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
    cleanDefs: true,
    cleanSymbols: true,
  });

  // Get all SVG files
  const allSvgFiles = getSvgFiles(SVG_DIR);

  if (allSvgFiles.length === 0) {
    console.warn('No SVG files found. Creating empty sprite.');
    ensureDirectoryExists(path.dirname(OUTPUT_PATH));
    fs.writeFileSync(OUTPUT_PATH, '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"></svg>');
    generateTypeDefinitions([]);
    return;
  }

  // Remove duplicates
  const svgFiles = deduplicateIcons(allSvgFiles);

  console.log(`Found ${allSvgFiles.length} SVG file(s), ${svgFiles.length} unique after normalization:`);

  const iconNames = [];

  // Add each SVG to the sprite
  svgFiles.forEach(({ name, originalName, path: filePath }) => {
    try {
      const svgContent = fs.readFileSync(filePath, 'utf8');
      sprites.add(name, svgContent);
      iconNames.push(name);
      console.log(`  ✓ ${name} (from ${originalName})`);
    } catch (error) {
      console.error(`  ✗ Error adding ${name}:`, error.message);
    }
  });

  // Ensure output directory exists
  ensureDirectoryExists(path.dirname(OUTPUT_PATH));

  // Write the sprite file
  const spriteContent = sprites.toString();
  fs.writeFileSync(OUTPUT_PATH, spriteContent);

  // Generate TypeScript type definitions
  generateTypeDefinitions(iconNames);

  console.log(`\nSprite generated successfully at: ${OUTPUT_PATH}`);
  console.log(`Total icons: ${svgFiles.length}`);
}

// Run the build
try {
  buildSprite();
} catch (error) {
  console.error('Error building sprite:', error);
  process.exit(1);
}
