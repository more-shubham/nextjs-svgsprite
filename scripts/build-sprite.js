#!/usr/bin/env node

/**
 * Build SVG Sprite Script
 * 
 * This script:
 * - Reads all .svg files from the svg-icons directory
 * - Combines them into a single SVG sprite
 * - Outputs the sprite to public/icons-sprite.svg
 */

const fs = require('fs');
const path = require('path');
const svgstore = require('svgstore');

// Configuration
const SVG_DIR = path.join(process.cwd(), 'svg-icons');
const OUTPUT_PATH = path.join(process.cwd(), 'public', 'icons-sprite.svg');
const TYPES_OUTPUT_PATH = path.join(process.cwd(), 'components', 'icon-types.ts');

/**
 * Normalize icon name to kebab-case
 * Converts: sunMoon, SunMoon, sun_moon, "sun moon", "sun  moon" â†’ sun-moon
 * 
 * @param {string} name - The original icon name
 * @returns {string} - The normalized kebab-case name
 */
function normalizeIconName(name) {
  return name
    // Replace multiple spaces with single space first
    .replace(/\s+/g, ' ')
    // Replace spaces with hyphens
    .replace(/\s/g, '-')
    // Handle PascalCase and camelCase: insert hyphen before uppercase letters
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    // Replace underscores with hyphens
    .replace(/_/g, '-')
    // Convert to lowercase
    .toLowerCase()
    // Remove any duplicate hyphens
    .replace(/-+/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-|-$/g, '');
}

/**
 * Ensure a directory exists, create if it doesn't
 */
function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Get all SVG files from a directory recursively
 * Supports namespaces via subdirectories (e.g., sidebar/home.svg â†’ sidebar:home)
 * Nested namespaces: sidebar/nav/icon.svg â†’ sidebar:nav:icon
 * All folder and file names are normalized to kebab-case
 */
function getSvgFiles(dir, namespace = '', originalNamespace = '') {
  if (!fs.existsSync(dir)) {
    console.warn(`Warning: SVG directory not found at ${dir}`);
    return [];
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];

  entries.forEach(entry => {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      // Normalize folder name to kebab-case
      const normalizedFolderName = normalizeIconName(entry.name);
      // Build namespace path with kebab-case folder names
      const newNamespace = namespace ? `${namespace}:${normalizedFolderName}` : normalizedFolderName;
      const newOriginalNamespace = originalNamespace ? `${originalNamespace}/${entry.name}` : entry.name;
      
      // Recursively process subdirectories as namespaces
      files = files.concat(getSvgFiles(fullPath, newNamespace, newOriginalNamespace));
    } else if (entry.isFile() && entry.name.endsWith('.svg')) {
      const originalFileName = path.basename(entry.name, '.svg');
      const normalizedFileName = normalizeIconName(originalFileName);
      const fullIconName = namespace ? `${namespace}:${normalizedFileName}` : normalizedFileName;
      const fullOriginalName = originalNamespace ? `${originalNamespace}/${originalFileName}` : originalFileName;
      
      files.push({
        originalName: fullOriginalName,
        name: fullIconName,
        path: fullPath,
      });
    }
  });

  return files;
}

/**
 * Remove duplicate icons and show warnings
 */
function deduplicateIcons(files) {
  const uniqueIcons = new Map();
  const duplicates = [];

  files.forEach(file => {
    if (uniqueIcons.has(file.name)) {
      // Found a duplicate
      const existing = uniqueIcons.get(file.name);
      if (!duplicates.some(d => d.name === file.name)) {
        duplicates.push({
          name: file.name,
          files: [existing.originalName, file.originalName]
        });
      } else {
        // Add to existing duplicate entry
        const dup = duplicates.find(d => d.name === file.name);
        dup.files.push(file.originalName);
      }
    } else {
      uniqueIcons.set(file.name, file);
    }
  });

  // Show errors for duplicates (always visible)
  if (duplicates.length > 0) {
    console.error('\nâŒ ERROR: Duplicate icon names detected after normalization:');
    duplicates.forEach(({ name, files }) => {
      console.error(`   "${name}" found in: [${files.join(', ')}]`);
    });
    console.error('   These duplicates have been removed. Only the first occurrence is kept.\n');
  }

  return Array.from(uniqueIcons.values());
}

/**
 * Generate TypeScript type definitions for icon names
 */
function generateTypeDefinitions(iconNames) {
  const typeDefinition = `/**
 * Auto-generated TypeScript types for SVG sprite icons
 * Generated from svg-icons directory
 * 
 * DO NOT EDIT THIS FILE MANUALLY - it is auto-generated
 */

export type IconName = ${iconNames.length > 0 ? iconNames.map(name => `'${name}'`).join(' | ') : 'never'};

export const iconNames = [${iconNames.map(name => `'${name}'`).join(', ')}] as const;
`;

  ensureDirectoryExists(path.dirname(TYPES_OUTPUT_PATH));
  fs.writeFileSync(TYPES_OUTPUT_PATH, typeDefinition);
  console.log(`\nTypeScript types generated at: ${TYPES_OUTPUT_PATH}`);
  
  if (iconNames.length === 0) {
    console.warn('âš ï¸  No icons found. IconName type is set to "never" to enforce type safety.');
    console.warn('   Add SVG files to svg-icons/ and re-run build:sprite to generate icon types.');
  }
}

/**
 * Group icons by namespace
 */
function groupByNamespace(files) {
  const groups = new Map();
  
  files.forEach(file => {
    // Extract namespace from icon name (e.g., "social:facebook" -> "social")
    const colonIndex = file.name.indexOf(':');
    let namespace = 'default'; // Root level icons
    let iconName = file.name;
    
    if (colonIndex > 0) {
      namespace = file.name.substring(0, colonIndex);
      iconName = file.name.substring(colonIndex + 1);
    }
    
    if (!groups.has(namespace)) {
      groups.set(namespace, []);
    }
    
    groups.get(namespace).push({
      ...file,
      iconName, // Name without namespace prefix
      fullName: file.name, // Full name with namespace
    });
  });
  
  return groups;
}

/**
 * Build the SVG sprite(s)
 */
function buildSprite() {
  console.log('Building SVG sprite(s)...');

  // Get all SVG files
  const allSvgFiles = getSvgFiles(SVG_DIR);

  if (allSvgFiles.length === 0) {
    console.warn('No SVG files found. Creating empty default sprite.');
    ensureDirectoryExists(path.dirname(OUTPUT_PATH));
    fs.writeFileSync(OUTPUT_PATH, '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"></svg>');
    generateTypeDefinitions([]);
    return;
  }

  // Remove duplicates
  const svgFiles = deduplicateIcons(allSvgFiles);

  console.log(`Found ${allSvgFiles.length} SVG file(s), ${svgFiles.length} unique after normalization:`);

  // Group icons by namespace
  const namespaceGroups = groupByNamespace(svgFiles);
  
  const allIconNames = [];
  const outputDir = path.dirname(OUTPUT_PATH);
  ensureDirectoryExists(outputDir);

  // Generate a separate sprite file for each namespace
  namespaceGroups.forEach((icons, namespace) => {
    const sprites = svgstore({
      svgAttrs: {
        xmlns: 'http://www.w3.org/2000/svg',
        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
        style: 'display: none;',
      },
      copyAttrs: ['fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
      cleanDefs: true,
      cleanSymbols: true,
    });

    console.log(`\nðŸ“¦ Building sprite for namespace: ${namespace}`);

    // Add each SVG to the namespace sprite
    icons.forEach(({ iconName, fullName, originalName, path: filePath }) => {
      try {
        const svgContent = fs.readFileSync(filePath, 'utf8');
        sprites.add(iconName, svgContent);
        allIconNames.push(fullName);
        console.log(`  âœ“ ${fullName} (from ${originalName})`);
      } catch (error) {
        console.error(`  âœ— Error adding ${fullName}:`, error.message);
      }
    });

    // Write the namespace sprite file
    const spriteFileName = namespace === 'default' 
      ? 'icons-sprite.svg' 
      : `icons-${namespace}.svg`;
    const spritePath = path.join(outputDir, spriteFileName);
    const spriteContent = sprites.toString();
    fs.writeFileSync(spritePath, spriteContent);
    
    console.log(`  âœ… Sprite saved: ${spriteFileName} (${icons.length} icons)`);
  });

  // Generate TypeScript type definitions
  generateTypeDefinitions(allIconNames);

  console.log(`\nâœ… All sprites generated successfully!`);
  console.log(`Total icons: ${svgFiles.length}`);
  console.log(`Namespaces: ${Array.from(namespaceGroups.keys()).join(', ')}`);
}

// Run the build
try {
  buildSprite();
} catch (error) {
  console.error('Error building sprite:', error);
  process.exit(1);
}
